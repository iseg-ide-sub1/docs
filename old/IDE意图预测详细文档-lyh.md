# IDE意图预测详细文档0915

[TOC]

## 相关成果

### user2code2vec

通过用户书写的代码作为个性表征。编码器有两种：词袋（抽象符号树与词频组成的矩阵）和嵌入（代码直接编码为向量）。
启发：要个性化用户开发习惯，开发行为能不能进一步抽象，探索对应的编码(向量化)方式？是不是要训练一个支持强化学习的分类器？它在模块中的位置是？与意图一同输出？还是作为意图预测的依据之一？

### **Recognizing Developer Activity Based on Joint Modeling of Code and Command Interactions**

> [!TIP]
>
> 这篇的思路比较重要

应用了那个丰富事件流数据集的一篇论文。**与我们的课题吻合度79%**
采用了无监督学习的方法，根据历史开发行为预测下一步的开发行为类型。
为了表征开发者的行为活动，提取了三类特征:

- 代码块：连续访问的对象的次数(CBO)；公共组件访问次数（CEA）；两个对象简单语法相似度。
- 开发强度：在一个交互片段内进行的编辑操作、IDE命令操作的数量；
- IDE命令：IDE命令的bigram分布（NLP中统计词的出现概率时用的模型，类似马尔科夫链），用于捕捉命令调用模式的变化

1. **类之间的耦合度(CBO)**:
     - 较高的CBO值对应于编辑、调试和导航相关的命令,反映了开发者在这些活动中访问了更多结构上相关的类。
     - 而打开不同类或构建项目的命令则CBO值较低,表明开发者在这些活动中访问的类之间联系较弱。
2. **编辑强度**:
     - 编辑强度指在一个交互片段内进行的编辑操作数量。
     - 该特征可以反映出开发者活动类型的转换,比如在某个时间点编辑强度出现大幅增加,表明开发者切换到了需要大量编辑的新活动。
3. **命令bigram分布的变化**:
     - 该特征用于捕捉命令调用模式的变化。
     - 命令bigram分布发生显著变化,表明开发者切换到了新的活动类型。
     - 与编辑强度的变化相结合,可以更好地识别开发者活动的转换。

预测所使用的模型：**Hierarchical Dirichlet Process Hidden Markov Mode**

使用隐马尔可夫模型捕捉上面三种特征之间的时序依赖关系,从而自动识别开发者的活动类型。

输入：开发序列，操作了某个类（可以理解为操作了某个Artifact）

中间产物：计算出三类特征

模型推理：根据三类特征，用马尔科夫模型计算出当前正在进行的活动类型（可以理解为状态机）

预测排行：每个类/IDE命令的分数 = 当前类/命令下的活动类型转换概率 * 当前类/命令下的活动内部操作概率

输出：得分高的类和命令排行，代表接下来最有可能操作的类和发出的IDE命令

![image-20240915165351184](./img/image-20240915165351184.png)

为了解释和验证该HDP-HMM模型的有效性,作者分析了模型学习到的6种潜在活动类型之间的转移概率,发现其与已有研究中观察到的开发者行为模式是一致的,如：

- 大部分活动类型倾向于自身转移,反映了开发者倾向于持续从事同一活动的特点;
- 调试活动与阅读和编辑活动之间有较强的转移,符合开发者在调试时会频繁切换到阅读和编辑代码的行为;
- 构建活动与调试活动之间有较强的转移,对应于现代IDE在每次启动调试前会自动重新构建软件的机制。

![image-20240915165204076](./img/image-20240915165204076.png)

对比实验：强于K-Means, 随机森林。

### Recording, Visualising and Understanding Developer Programming Behaviour

建模开发者理解和使用一个repo时的行为习惯。

开发者最初似乎定位到一个合适的起点,然后阅读周围的代码以扩展知识,执行代码编辑,最后验证编辑结果。但进一步细致分析发现,开发者可能更多使用一种递归方法:他们可能识别出一个合适的焦点点作为起点,然后通过调查这个焦点点与程序的关系来扩展知识。但与假设不同的是,开发者似乎并不一定只是继续前进,而是倾向于重新开始,即使用已获得的部分知识来找到一个更好的起点重新开始。

[6](https://app.txyz.ai/chat/96c08de9-6144-4c0f-8196-8f2e12bd5564)研究还发现,虽然高评分参与者通过较少的步骤和较短的时间解决了任务,但也有一些参与者由于知识或专业水平较低,需要更长的时间和更多的步骤,但最终也完成了任务。后者可能需要某种(工具)辅助,因为可观察到他们在重复某些行为模式,表明他们在完成任务时遇到了困难。

## 思路/技术路线

### 总体设计

我们的模块叫做@VirtualMe，分析和模拟开发者的**开发惯性**。基于过去一段时间开发动作序列，给上层智能体提供当前开发者有可能进行的下一步工作。

**输入**：@VirtualMe（**子问题**，回溯步长，操作类型，至多候选数量）询问：针对该问题，依据多久之前以内的行为，对于某类型的活动，接下来可能执行什么操作？给出几个来。这里的子问题更偏向于关键词，用于对预测列表进行筛选。

**返回值**：按可能性排序的接下来可能进行的操作列表；当前正在执行的任务类型；特征向量[领域，熟练程度]

> 例1：
>
> 其他智能体：@VirtualMe（sheet, 2 mins，file | artifact，3）
>
> VirtualMe：file：myTest.csv，otherTest.csv；artifact：reader.py->void:ReadSheet()，utils.py->class:SheetFiller，myTest.csv->line2col3；Edit；[Python dev, new]
>
> 例2：
>
> 其他智能体：@VirtualMe（build the netModule，5mins，file | cmd，1)
>
> VirtualMe：file：net/BUILD.gn；cmd：build/compile；Read；[C++, old]
>
> 例3：
>
> 其他智能体：@VirtualMe（solve compile error，30mins，file，4)
>
> VirtualMe：file：CMakeLists.txt，subModule1.cmake，lib.h，lib.cpp；Debug；[C++, new]
>
> 例4：
>
> 其他智能体：@VirtualMe（refactor void:solve，10mins，artifact，4)
>
> VirtualMe：artifact：my_lib/api.py->void:solve, chatbot.py->void:processProblem, …；ReFactor）；[Python, old]

### 技术方案（结合了状态机和其他模型）

因为涉及个性化数据收集和定期调整学习，该模块使用的模型很大概率是**部署在端侧**的，随着开发者用户使用而更新的。

参考第二篇的行为建模，总体上应该有一个状态机来描述开发者的可能在进行的大任务，对应老师提的最高层的Task，举例：

1. 阅读查看（打开过什么文件、鼠标点击过哪些行、ctrl执行过哪些快速跳转，鼠标滚轮）
2. 执行构建（命令行执行.sh、.bat、.py等文件）
3. repo指令（git拉取、commit、提交等）
4. debug（终端报错，IDE代码检查报错，频繁修改某部分）
5. 暂停（无操作）
6. 编辑
7. *使用别的软件比如浏览器上问过什么
8. *代码重构
9. 版本控制（冲突合并）

每个状态代表一个状态空间，空间里面有具体的操作，对应于老师提的第二层的element，有三种，举例：

1. file（操作过什么文件）
2. artifact（文件，类、类方法、API、属性、任何结构化文档的元素）
3. IDE操作（重命名、搜索、重构等）

模块流程如下：

1. **从element层面提取抽象特征**。
     相比前述研究只考虑class和IDE命令，我们的element种类更丰富，需要更合适的特征计算法？
2. 根据前几步操作的抽象特征，**计算当前所处的状态空间(Task)**（以上8种的哪种）。
     前述研究使用隐马尔科夫模型，主要的考虑是结合多元特征维度。我们该怎么选。实际上就是训练一个聚类/分类器。
     也可以把1,2步合并，直接训练一个基于Transformer的分类器？具体的模型设计我不会。

2. 根据当前所处的状态空间，结合抽象特征，**给所有涉及到的element计算概率分数并排序**。
     不太好描述，就是个条件概率公式。但是原算法要遍历所有element，在我们这会引入性能问题。该怎么解决？
     可能的解决方案：训练一个分类器先缩小element范围？
3. 根据子问题提供的关键词，从候选element中**过滤出相似度最高的一批**。
     使用NLP里的某个相似度算法，例如余弦相似度。

### 开发者个性化数据学习策略PMMI

前述的开发动作预测实际上已经是个性化建模的一种。但是要进一步地进行人格特征学习该怎么办：

第一篇的思路更像是代码风格的建模。

第三篇是在建模开发者理解和使用一个repo时的行为习惯。

两个维度的特征我们都需要。结合这两篇的技术，可能有如下技术路线：

首先要清楚开发者的人格特征对于上层智能体的决策有何改善。

比如我是一个专门做软件测试的工程师，之前已经在IDE内编写了很多相关内容。当前的需求是写一个批量测试脚本。如果智能体不知道我是专业的，可能会从安装依赖包、脚本存放位置、业界规范开始喋喋不休引入话题；如果智能体事先知道了我是专业团队，可能会直接给测试脚本的内容不多废话。

反之如果我是菜鸟，甚至不能配环境。智能体基于这个事实给出的回答应当更加通俗易理解，倾向于step by step。

**开发者的特征分为两个有限元维度**：

1. 领域Field：软件测试、C++开发、PHP前端、GO数据分析、C网络安全、Python深度学习等
2. 熟练程度：新手、熟练

根据开发者使用的语言、项目的类型、开发历程建模，在本地随时训练一个可更新的分类器，输出开发者当前的**特征向量[领域，熟练程度]**，相当于给上层智能体一个关键词提示。

**领域识别：**

编程语言+标志性配置文件和三方包(CMakeLists, gradle, pytorch)，进行基于规则的识别。

**熟练度识别：**

参考1,3两篇论文，分别从编码风格和task解决效率来评估。

- 编码风格：词袋or直接编码嵌入分类器
- task解决效率：可以结合状态机？比如经常徘徊在一个状态内视为不熟练，结合经常所处的状态打分例如：
     git行为+1分，debug(终端报错)-2分，执行构建/阅读查看0分，编辑+1分。然后拿来喂分类器。

### 数据集构建

需要训几个模型就需要构建几个对应的数据集。我感觉问题比较复杂，不是一个模型就能解决的。

1. 编写IDE插件0.1版本，仅收集各类开发动作。形成原始数据集（或者直接挪用丰富事件流的数据集）
2. 根据element抽象特征提取算法，按照规定的步长给数据集分不同段，每段附带对应的抽象特征，并人工标注Task。形成elements-task数据集。（对应于流程第二步要训练的模型）
3. 对应于流程第三步可能需要的模型
4. 构建包含新手和老手开发行为的数据集（维度包括代码内容和开发行为状态等），并打标。



TODO：

状态机：已有的，自己构建的

状态机是不是已有最先进的思路

用状态机建模

找熟练度识别的**理论依据**

聚类能不能解决我们的问题：类数量不确定，会实时更新任务状态库

聚类？是否用基于规则的识别Task

看IDE Workshop里的论文

