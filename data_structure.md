# IDE动作序列数据建模方法v0.2

[TOC]

# 方案：1+N，1个模型预测操作类型，分方案预测具体操作

## 原始数据

要满足下面的操作建模，需要收集的raw_data应当有以下内容：

**时间戳 + 操作事件 + 记录内容**

| 操作/事件                                | 记录内容                                                     |
| ---------------------------------------- | ------------------------------------------------------------ |
| 纯文本文件编辑(包含选中)                 | **文件位置**：格式例如folder1/folder2/utils.py<br />**编辑位置**：行号范围格式例如2:3<br />**编辑内容**：增删改选了什么 |
| 源代码编辑(包含选中、代码补全tab等)      | **文件位置**<br />**编辑位置**<br />**编辑内容**<br />**编辑的符号名**：格式例如function1<br />**编辑的符号的嵌套关系**：格式例如[art1, art2, art3]<br />**编辑的符号(包含上级符号)声明的位置**：格式例如：[art1, art2, art3]，每个art格式例如{文件位置，编辑位置，编辑的符号名}<br />**编辑的符号(包含上级符号)所有引用的位置**：格式例如：[art1, art2, art3]，每个art格式例如{文件位置，编辑位置，编辑的符号名}<br />**编辑的符号(包含上级符号)所有父类的位置**：多态意义上的继承自己的类，格式例如：[art1, art2, art3]，每个art格式例如{文件位置，行号位置，符号名}<br />**编辑的符号(包含上级符号)所有子类的位置**：多态意义上的实现自己的类，格式例如：[art1, art2, art3]，每个art格式例如{文件位置，行号位置，符号名} |
| 鼠标滚动                                 | **文件位置**<br />**编辑位置**                               |
| 文件级操作（新建删除移动打开关闭重命名） | **文件位置**<br />**移动/重命名后文件位置**                  |
| 搜索/替换                                | **搜索内容**<br />**替换内容**                               |
| 重命名符号(IDE右键操作)                  | **原符号名**<br />**替换符号名**<br />**编辑的符号的嵌套关系**<br />**编辑的符号(包含上级符号)声明的位置**<br />**编辑的符号(包含上级符号)所有引用的位置**<br />**编辑的符号(包含上级符号)所有父类的位置**<br />**编辑的符号(包含上级符号)所有子类的位置** |
| 终端命令行操作                           | **命令内容**：格式例如pip install XXX，g++ -c main.cpp，python train.py |
| IDE执行操作                              | **文件位置**：即运行的哪个脚本                               |
| 终端输出信息                             | **终端输出的内容**：不管是不是报错，全部收集，预处理时再过滤 |
| IDE静态检查问题                          | **问题描述**：如果检测出现了静态检查报错，则记录一次，之后不重复记录。 |



## 操作建模

用具体的工件之间的相关性+环境反馈代替原本每个操作的具体工件，类似于差分，避免模型输出与频繁变动的操作件绑定。相当于记录节点之间的边的信息。

这些内容要根据raw_data进一步预处理获得，但是在信息量足够的情况下只需要基于规则，并不复杂。

```python
<操作向量> = torch.stack(
	<操作类型>, <环境反馈信息>, <跳转方向>, <待补充>
)

<操作类型> = map[  # 数值映射
    fix_for_terminal,  # 终端报错，下一步要修复bug
    fix_for_static,  # 静态检查报错，下一步要修复bug
    note,  # 编辑注释
    tab,  # 代码补全
	search,   # 搜索
    replace,  # 替换
    edit_code,  # 编辑代码，除去修复问题、代码补全、搜索替换的编辑行为
    refactor,  # 重构符号名（IDE内置操作）
    rename_file,  # 重命名文件
    delete_file,  # 删除文件
    create_file,  # 新建文件
    move_file,  # 移动文件
    ask_agent,  # 人智交互，使用AI编程助手的相关功能
    read,  # 看文件看代码，连续滚动、选中等操作但是不编辑
    env,  # 配置环境
    action,  # 执行
    debug，  # 调试
]

<环境反馈信息> = binary_bool[  # 二进制编码后是唯一的数值
    terminal_env,  # 环境相关报错
    terminal_runtime,  # 程序运行时报错
    terminal_compile,  # 解释编译报错
    terminal_link,  # 终端的报错信息是否与前x步的操作件有关系
    static_error,  # 静态检查报错
]

<跳转方向> = binary_bool[  # 二进制编码后是唯一的数值
    on_current_artifact,  # 现在的操作件前x步内是不是操作过
    ref_son,  # 现在的操作件继承自前x步的操作件（多态）
    ref_father,  # 现在的操作件是前x步操作件的父类（多态）
    ref_rely,  # 现在的操作件调用了前x步的操作件
    ref_api,  # 现在的操作件被前x步的操作件调用
    ref_simlilar,  # 现在的操作件与前x步的操作件内容相似
]
```

## 端到端格式

**输入：一段操作序列**

```python
input,shape = (batch, time, in_features)
time = 最大回溯长度
in_features = <操作向量>
```

**输出：操作倾向性/状态**

```python
output.shape = (batch, out_featrues)
out_features = [<操作类型>, <跳转方向>]

<操作类型> = one-hot[同前]
<跳转方向> = binary_value(同)
```

## 具体操作内容预测

对于每一类**操作类型**，有不同的对应的操作内容计算方法。要结合更加具体的**环境反馈**和**跳转方向**信息。

例如：

**fix_for_terminal**：预测出要进行终端报错的修复后，先获取终端报错信息，在Traceback中找到具体抛出错误的artifact，就是该操作对应的预测工件，fix_for_static同理，再结合跳转方向即可。
